---
import BaseLayout from '../../layouts/BaseLayout.astro';
import AudioPlayer from '../../components/AudioPlayer.astro';
import TranscriptSegment from '../../components/TranscriptSegment.astro';
import { getAllPodcasts, getPodcastById } from '../../lib/podcasts';

export async function getStaticPaths() {
  const podcasts = await getAllPodcasts();
  return podcasts.map(podcast => ({
    params: { id: podcast.id }
  }));
}

const { id } = Astro.params;
const podcast = await getPodcastById(id!);

if (!podcast) {
  return Astro.redirect('/');
}

const defaultTrack = podcast.tracks[0];
---
<BaseLayout title={podcast.title}>
  <a href="/" class="inline-flex items-center text-blue-600 hover:text-blue-800 hover:underline mb-6 text-sm">
    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
    </svg>
    Back to all podcasts
  </a>

  <h1 class="text-3xl font-bold text-gray-900 mb-6">{podcast.title}</h1>

  <!-- Track Tabs -->
  <div class="mb-6">
    <div class="flex border-b border-gray-200 overflow-x-auto">
      {podcast.tracks.map((track, index) => (
        <button
          class={`track-tab px-4 py-2 font-medium text-sm border-b-2 transition-colors whitespace-nowrap ${
            index === 0
              ? 'border-blue-600 text-blue-600 bg-blue-50'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'
          }`}
          data-track={track.id}
        >
          {track.label}
        </button>
      ))}
    </div>
  </div>

  <!-- Track Content -->
  {podcast.tracks.map((track, index) => (
    <div
      class={`track-content ${index === 0 ? '' : 'hidden'}`}
      data-track-content={track.id}
    >
      <!-- Summary -->
      <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-4 mb-6 border border-blue-100">
        <h2 class="font-semibold text-gray-800 mb-2 flex items-center gap-2">
          <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
          </svg>
          Summary
        </h2>
        <p class="text-gray-700 text-sm leading-relaxed">{track.transcript.summary}</p>
      </div>

      <!-- Audio Player -->
      <div class="mb-6">
        <AudioPlayer trackId={track.id} audioPath={track.audioPath} />
      </div>

      <!-- Transcript -->
      <div class="bg-white rounded-lg shadow border border-gray-100 overflow-hidden">
        <div class="bg-gray-50 px-4 py-3 border-b border-gray-100">
          <h2 class="font-semibold text-gray-800 flex items-center gap-2">
            <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
            </svg>
            Transcript
            <span class="text-xs font-normal text-gray-500">
              (Click timestamp to jump)
            </span>
          </h2>
        </div>
        <div
          class="transcript-container space-y-1 max-h-[500px] overflow-y-auto p-4"
          data-transcript-for={track.id}
        >
          {track.transcript.segments.map((segment, i) => (
            <TranscriptSegment segment={segment} index={i} />
          ))}
        </div>
      </div>
    </div>
  ))}
</BaseLayout>

<script>
  // Tab switching functionality
  function initTabs() {
    const tabs = document.querySelectorAll('.track-tab');
    const contents = document.querySelectorAll('.track-content');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const trackId = (tab as HTMLElement).dataset.track;

        // Update tab styles
        tabs.forEach(t => {
          t.classList.remove('border-blue-600', 'text-blue-600', 'bg-blue-50');
          t.classList.add('border-transparent', 'text-gray-500');
        });
        tab.classList.add('border-blue-600', 'text-blue-600', 'bg-blue-50');
        tab.classList.remove('border-transparent', 'text-gray-500');

        // Show/hide content
        contents.forEach(content => {
          if ((content as HTMLElement).dataset.trackContent === trackId) {
            content.classList.remove('hidden');
          } else {
            content.classList.add('hidden');
          }
        });
      });
    });
  }

  // Audio player functionality
  function formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }

  function parseTimestamp(timestamp: string): number {
    const [minutes, seconds] = timestamp.split(':').map(Number);
    return minutes * 60 + seconds;
  }

  function initAudioPlayers() {
    const players = document.querySelectorAll('.audio-player');

    players.forEach(playerEl => {
      const player = playerEl as HTMLElement;
      const trackId = player.dataset.trackId!;
      const audio = player.querySelector('audio') as HTMLAudioElement;
      const playBtn = player.querySelector('.play-btn') as HTMLButtonElement;
      const playIcon = player.querySelector('.play-icon') as SVGElement;
      const pauseIcon = player.querySelector('.pause-icon') as SVGElement;
      const progressContainer = player.querySelector('.progress-container') as HTMLElement;
      const progressBar = player.querySelector('.progress-bar') as HTMLElement;
      const progressHandle = player.querySelector('.progress-handle') as HTMLElement;
      const currentTimeEl = player.querySelector('.current-time') as HTMLElement;
      const durationEl = player.querySelector('.duration') as HTMLElement;
      const volumeSlider = player.querySelector('.volume-slider') as HTMLInputElement;
      const muteBtn = player.querySelector('.mute-btn') as HTMLButtonElement;
      const volumeIcon = muteBtn?.querySelector('.volume-icon') as SVGElement;
      const mutedIcon = muteBtn?.querySelector('.muted-icon') as SVGElement;

      const transcriptContainer = document.querySelector(`[data-transcript-for="${trackId}"]`);
      const segments = transcriptContainer?.querySelectorAll('.transcript-segment') || [];

      let currentSegmentIndex = -1;

      // Play/Pause toggle
      playBtn.addEventListener('click', () => {
        if (audio.paused) {
          audio.play();
        } else {
          audio.pause();
        }
      });

      audio.addEventListener('play', () => {
        playIcon.classList.add('hidden');
        pauseIcon.classList.remove('hidden');
      });

      audio.addEventListener('pause', () => {
        playIcon.classList.remove('hidden');
        pauseIcon.classList.add('hidden');
      });

      // Time update - real-time progress
      audio.addEventListener('timeupdate', () => {
        if (!audio.duration) return;
        const progress = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${progress}%`;
        progressHandle.style.left = `${progress}%`;
        currentTimeEl.textContent = formatTime(audio.currentTime);

        // Highlight current transcript segment
        highlightCurrentSegment(audio.currentTime);
      });

      audio.addEventListener('loadedmetadata', () => {
        durationEl.textContent = formatTime(audio.duration);
      });

      // Click on progress bar to seek
      progressContainer.addEventListener('click', (e) => {
        const rect = progressContainer.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        audio.currentTime = percent * audio.duration;
      });

      // Volume control
      if (volumeSlider) {
        volumeSlider.addEventListener('input', () => {
          audio.volume = parseFloat(volumeSlider.value);
          updateVolumeIcon();
        });
      }

      if (muteBtn) {
        muteBtn.addEventListener('click', () => {
          audio.muted = !audio.muted;
          updateVolumeIcon();
        });
      }

      function updateVolumeIcon() {
        if (!volumeIcon || !mutedIcon) return;
        if (audio.muted || audio.volume === 0) {
          volumeIcon.classList.add('hidden');
          mutedIcon.classList.remove('hidden');
        } else {
          volumeIcon.classList.remove('hidden');
          mutedIcon.classList.add('hidden');
        }
      }

      // Click on transcript to seek
      segments.forEach((segment) => {
        segment.addEventListener('click', () => {
          const timestamp = (segment as HTMLElement).dataset.timestamp!;
          audio.currentTime = parseTimestamp(timestamp);
          if (audio.paused) {
            audio.play();
          }
        });
      });

      // Highlight current segment based on playback time
      function highlightCurrentSegment(currentTime: number) {
        let activeIndex = -1;

        segments.forEach((segment, index) => {
          const timestamp = parseTimestamp((segment as HTMLElement).dataset.timestamp!);
          const nextSegment = segments[index + 1];
          const nextTimestamp = nextSegment
            ? parseTimestamp((nextSegment as HTMLElement).dataset.timestamp!)
            : Infinity;

          if (currentTime >= timestamp && currentTime < nextTimestamp) {
            activeIndex = index;
          }
        });

        if (activeIndex !== currentSegmentIndex) {
          // Remove highlight from all segments
          segments.forEach(s => {
            s.classList.remove('!bg-blue-100', '!border-l-blue-500');
          });

          // Add highlight to current segment
          if (activeIndex >= 0) {
            const activeSegment = segments[activeIndex];
            activeSegment.classList.add('!bg-blue-100', '!border-l-blue-500');

            // Auto-scroll to segment
            activeSegment.scrollIntoView({
              behavior: 'smooth',
              block: 'nearest'
            });
          }

          currentSegmentIndex = activeIndex;
        }
      }
    });
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    initTabs();
    initAudioPlayers();
  });

  // Also initialize on Astro page transitions
  document.addEventListener('astro:page-load', () => {
    initTabs();
    initAudioPlayers();
  });
</script>
