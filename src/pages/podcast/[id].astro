---
import BaseLayout from '../../layouts/BaseLayout.astro';
import AudioPlayer from '../../components/AudioPlayer.astro';
import TranscriptSegment from '../../components/TranscriptSegment.astro';
import { getAllPodcasts, getPodcastById } from '../../lib/podcasts';

export async function getStaticPaths() {
  const podcasts = await getAllPodcasts();
  return podcasts.map((podcast, index) => ({
    params: { id: podcast.id },
    props: { nextPodcastId: podcasts[index + 1]?.id || null }
  }));
}

const { id } = Astro.params;
const { nextPodcastId } = Astro.props;
const podcast = await getPodcastById(id!);

if (!podcast) {
  return Astro.redirect('/');
}

const defaultTrack = podcast.tracks[0];
---
<BaseLayout title={podcast.title}>
  <a href="/" class="inline-flex items-center text-blue-600 hover:text-blue-800 hover:underline mb-6 text-sm">
    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
    </svg>
    Back to all podcasts
  </a>

  <h1 class="text-3xl font-bold text-gray-900 mb-6">{podcast.title}</h1>

  <!-- Track Tabs -->
  <div class="mb-6">
    <div class="flex border-b border-gray-200 overflow-x-auto">
      {podcast.tracks.map((track, index) => (
        <button
          class={`track-tab px-4 py-2 font-medium text-sm border-b-2 transition-colors whitespace-nowrap ${
            index === 0
              ? 'border-blue-600 text-blue-600 bg-blue-50'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'
          }`}
          data-track={track.id}
        >
          {track.label}
        </button>
      ))}
    </div>
  </div>

  <!-- Track Content -->
  {podcast.tracks.map((track, index) => (
    <div
      class={`track-content ${index === 0 ? '' : 'hidden'}`}
      data-track-content={track.id}
    >
      <!-- Summary -->
      <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl p-6 mb-8 border border-blue-100">
        <h2 class="font-semibold text-gray-800 mb-3 flex items-center gap-2 text-lg">
          <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
          </svg>
          Summary
        </h2>
        <p class="text-gray-700 text-lg leading-relaxed">{track.transcript.summary}</p>
      </div>

      <!-- Audio Player (sticky at bottom when scrolling) -->
      <div class="audio-player-wrapper mb-6" data-player-wrapper={track.id}>
        <AudioPlayer trackId={track.id} audioPath={track.audioPath} />
      </div>

      <!-- Transcript -->
      <div class="bg-white rounded-xl shadow border border-gray-100 overflow-hidden">
        <div class="bg-gray-50 px-6 py-4 border-b border-gray-100">
          <h2 class="font-semibold text-gray-800 flex items-center gap-2 text-lg">
            <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
            </svg>
            Transcript
            <span class="text-sm font-normal text-gray-500">
              (Click timestamp to jump)
            </span>
          </h2>
        </div>
        <div
          class="transcript-container space-y-2 max-h-[600px] overflow-y-auto p-6"
          data-transcript-for={track.id}
        >
          {track.transcript.segments.map((segment, i) => (
            <TranscriptSegment segment={segment} index={i} />
          ))}
        </div>
      </div>
    </div>
  ))}
</BaseLayout>

<script define:vars={{ nextPodcastId }}>
  window.__NEXT_PODCAST_ID__ = nextPodcastId;
</script>

<script>
  // Tab switching functionality
  function getTabStorageKey(): string {
    const podcastId = getPodcastId();
    return `podcast_${podcastId}_active_tab`;
  }

  function initTabs() {
    const tabs = document.querySelectorAll('.track-tab');
    const contents = document.querySelectorAll('.track-content');
    const tabStorageKey = getTabStorageKey();

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const trackId = (tab as HTMLElement).dataset.track;

        // Save selected tab to localStorage
        if (trackId) {
          localStorage.setItem(tabStorageKey, trackId);
        }

        // Update tab styles
        tabs.forEach(t => {
          t.classList.remove('border-blue-600', 'text-blue-600', 'bg-blue-50');
          t.classList.add('border-transparent', 'text-gray-500');
        });
        tab.classList.add('border-blue-600', 'text-blue-600', 'bg-blue-50');
        tab.classList.remove('border-transparent', 'text-gray-500');

        // Show/hide content
        contents.forEach(content => {
          if ((content as HTMLElement).dataset.trackContent === trackId) {
            content.classList.remove('hidden');
          } else {
            content.classList.add('hidden');
          }
        });
      });
    });

    // Restore saved tab on page load
    const savedTab = localStorage.getItem(tabStorageKey);
    if (savedTab) {
      const tabToSelect = document.querySelector(`.track-tab[data-track="${savedTab}"]`) as HTMLElement;
      if (tabToSelect) {
        tabToSelect.click();
      }
    }
  }

  // Audio player functionality
  function formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }

  function parseTimestamp(timestamp: string): number {
    const [minutes, seconds] = timestamp.split(':').map(Number);
    return minutes * 60 + seconds;
  }

  // Get podcast ID from URL
  function getPodcastId(): string {
    const path = window.location.pathname;
    const match = path.match(/\/podcast\/([^/]+)/);
    return match ? match[1] : '';
  }

  // LocalStorage key for saving progress
  function getStorageKey(trackId: string): string {
    return `podcast_${getPodcastId()}_${trackId}_progress`;
  }

  function initAudioPlayers() {
    const players = document.querySelectorAll('.audio-player');

    players.forEach(playerEl => {
      const player = playerEl as HTMLElement;
      const trackId = player.dataset.trackId!;
      const audio = player.querySelector('audio') as HTMLAudioElement;
      const playBtn = player.querySelector('.play-btn') as HTMLButtonElement;
      const playIcon = player.querySelector('.play-icon') as SVGElement;
      const pauseIcon = player.querySelector('.pause-icon') as SVGElement;
      const progressContainer = player.querySelector('.progress-container') as HTMLElement;
      const progressBar = player.querySelector('.progress-bar') as HTMLElement;
      const progressHandle = player.querySelector('.progress-handle') as HTMLElement;
      const currentTimeEl = player.querySelector('.current-time') as HTMLElement;
      const durationEl = player.querySelector('.duration') as HTMLElement;
      const volumeSlider = player.querySelector('.volume-slider') as HTMLInputElement;
      const muteBtn = player.querySelector('.mute-btn') as HTMLButtonElement;
      const volumeIcon = muteBtn?.querySelector('.volume-icon') as SVGElement;
      const mutedIcon = muteBtn?.querySelector('.muted-icon') as SVGElement;

      const transcriptContainer = document.querySelector(`[data-transcript-for="${trackId}"]`);
      const segments = transcriptContainer?.querySelectorAll('.transcript-segment') || [];
      const wrapper = document.querySelector(`[data-player-wrapper="${trackId}"]`) as HTMLElement;

      let currentSegmentIndex = -1;

      // Restore saved progress from localStorage
      const storageKey = getStorageKey(trackId);
      const savedProgress = localStorage.getItem(storageKey);

      function restoreProgress() {
        if (savedProgress && audio.duration) {
          const savedTime = parseFloat(savedProgress);
          if (savedTime > 0 && savedTime < audio.duration) {
            audio.currentTime = savedTime;
            // Update UI
            const progress = (savedTime / audio.duration) * 100;
            progressBar.style.width = `${progress}%`;
            progressHandle.style.left = `${progress}%`;
            currentTimeEl.textContent = formatTime(savedTime);
          }
        }
        durationEl.textContent = formatTime(audio.duration);
      }

      // Check if metadata already loaded (for cached audio)
      if (audio.readyState >= 1) {
        restoreProgress();
      }

      audio.addEventListener('loadedmetadata', restoreProgress);

      // Save progress to localStorage periodically
      let lastSavedTime = -1;
      audio.addEventListener('timeupdate', () => {
        if (!audio.duration) return;
        const progress = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${progress}%`;
        progressHandle.style.left = `${progress}%`;
        currentTimeEl.textContent = formatTime(audio.currentTime);

        // Save progress in real-time (skip saving 0 to avoid overwriting on auto-play start)
        // Only save if time changed by at least 0.5s to reduce writes
        if (audio.currentTime > 0.5 && Math.abs(audio.currentTime - lastSavedTime) >= 0.5) {
          localStorage.setItem(storageKey, audio.currentTime.toString());
          lastSavedTime = audio.currentTime;
        }

        // Highlight current transcript segment
        highlightCurrentSegment(audio.currentTime);
      });

      // Play/Pause toggle
      playBtn.addEventListener('click', () => {
        if (audio.paused) {
          audio.play();
        } else {
          audio.pause();
        }
      });

      audio.addEventListener('play', () => {
        playIcon.classList.add('hidden');
        pauseIcon.classList.remove('hidden');
      });

      audio.addEventListener('pause', () => {
        playIcon.classList.remove('hidden');
        pauseIcon.classList.add('hidden');
        // Save progress on pause to capture exact position
        if (audio.currentTime > 0.5) {
          localStorage.setItem(storageKey, audio.currentTime.toString());
        }
      });

      // Auto-play next track when current one ends
      const trackOrder = ['dg', 'pb', 'rv'];
      audio.addEventListener('ended', () => {
        const currentIndex = trackOrder.indexOf(trackId);
        if (currentIndex < trackOrder.length - 1) {
          // Play next track in same episode
          const nextTrackId = trackOrder[currentIndex + 1];

          // Clear saved progress for next track so it starts fresh
          const nextStorageKey = getStorageKey(nextTrackId);
          localStorage.removeItem(nextStorageKey);

          // Switch to next tab
          const nextTab = document.querySelector(`.track-tab[data-track="${nextTrackId}"]`) as HTMLElement;
          if (nextTab) {
            nextTab.click();

            // Play next audio after a short delay for tab switch
            setTimeout(() => {
              const nextAudio = document.querySelector(`#audio-${nextTrackId}`) as HTMLAudioElement;
              if (nextAudio) {
                nextAudio.currentTime = 0;
                nextAudio.play();
              }
            }, 100);
          }
        } else {
          // Last track (rv) ended, go to next podcast episode
          const nextPodcastId = (window as any).__NEXT_PODCAST_ID__;
          if (nextPodcastId) {
            // Set flag to auto-play dg on next page
            localStorage.setItem('autoplay_next_podcast', 'true');
            // Clear progress for next podcast's dg track
            localStorage.removeItem(`podcast_${nextPodcastId}_dg_progress`);
            // Navigate to next podcast
            window.location.href = `/podcast/${nextPodcastId}`;
          }
        }
      });

      // Click on progress bar to seek
      progressContainer.addEventListener('click', (e) => {
        const rect = progressContainer.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        audio.currentTime = percent * audio.duration;
      });

      // Volume control
      if (volumeSlider) {
        volumeSlider.addEventListener('input', () => {
          audio.volume = parseFloat(volumeSlider.value);
          updateVolumeIcon();
        });
      }

      if (muteBtn) {
        muteBtn.addEventListener('click', () => {
          audio.muted = !audio.muted;
          updateVolumeIcon();
        });
      }

      function updateVolumeIcon() {
        if (!volumeIcon || !mutedIcon) return;
        if (audio.muted || audio.volume === 0) {
          volumeIcon.classList.add('hidden');
          mutedIcon.classList.remove('hidden');
        } else {
          volumeIcon.classList.remove('hidden');
          mutedIcon.classList.add('hidden');
        }
      }

      // Click on transcript to seek
      segments.forEach((segment) => {
        segment.addEventListener('click', () => {
          const timestamp = (segment as HTMLElement).dataset.timestamp!;
          audio.currentTime = parseTimestamp(timestamp);
          if (audio.paused) {
            audio.play();
          }
        });
      });

      // Highlight current segment based on playback time
      function highlightCurrentSegment(currentTime: number) {
        let activeIndex = -1;

        segments.forEach((segment, index) => {
          const timestamp = parseTimestamp((segment as HTMLElement).dataset.timestamp!);
          const nextSegment = segments[index + 1];
          const nextTimestamp = nextSegment
            ? parseTimestamp((nextSegment as HTMLElement).dataset.timestamp!)
            : Infinity;

          if (currentTime >= timestamp && currentTime < nextTimestamp) {
            activeIndex = index;
          }
        });

        if (activeIndex !== currentSegmentIndex) {
          // Remove highlight from all segments
          segments.forEach(s => {
            s.classList.remove('!bg-blue-100', '!border-l-blue-500');
          });

          // Add highlight to current segment
          if (activeIndex >= 0 && transcriptContainer) {
            const activeSegment = segments[activeIndex] as HTMLElement;
            activeSegment.classList.add('!bg-blue-100', '!border-l-blue-500');

            // Auto-scroll only when segment is at or below the bottom of visible area
            const container = transcriptContainer as HTMLElement;
            const containerRect = container.getBoundingClientRect();
            const segmentRect = activeSegment.getBoundingClientRect();
            const segmentHeight = segmentRect.height;
            const containerHeight = containerRect.height;

            // Check if segment is at bottom or out of view
            const segmentRelativeTop = segmentRect.top - containerRect.top;
            const segmentBottom = segmentRect.bottom - containerRect.top;
            const isAtBottom = segmentBottom > containerHeight - segmentHeight;
            const isOutOfView = segmentRelativeTop < 0 || segmentBottom > containerHeight;

            if (isAtBottom || isOutOfView) {
              // Scroll to position segment at second to last line from bottom
              const targetPosition = containerHeight - 2 * segmentHeight;
              const scrollDelta = segmentRelativeTop - targetPosition;

              container.scrollTo({
                top: Math.max(0, container.scrollTop + scrollDelta),
                behavior: 'smooth'
              });
            }
          }

          currentSegmentIndex = activeIndex;
        }
      }
    });
  }

  // Sticky audio player on scroll
  function initStickyPlayer() {
    const wrappers = document.querySelectorAll('.audio-player-wrapper');

    wrappers.forEach(wrapper => {
      const wrapperEl = wrapper as HTMLElement;
      const player = wrapperEl.querySelector('.audio-player') as HTMLElement;
      if (!player) return;

      // Create placeholder for when player becomes fixed
      const placeholder = document.createElement('div');
      placeholder.style.display = 'none';
      wrapperEl.insertBefore(placeholder, player);

      let isSticky = false;

      function checkSticky() {
        const rect = wrapperEl.getBoundingClientRect();
        const trackContent = wrapperEl.closest('.track-content');
        const isVisible = trackContent && !trackContent.classList.contains('hidden');

        if (!isVisible) {
          // Reset if tab is hidden
          if (isSticky) {
            player.classList.remove('fixed', 'bottom-0', 'left-0', 'right-0', 'z-50', 'shadow-lg', 'border-t', 'border-gray-200');
            player.style.maxWidth = '';
            placeholder.style.display = 'none';
            document.body.style.paddingBottom = '';
            isSticky = false;
          }
          return;
        }

        const shouldBeSticky = rect.bottom < 0 || rect.top > window.innerHeight;

        if (shouldBeSticky && !isSticky) {
          // Make sticky
          const playerHeight = player.offsetHeight;
          placeholder.style.height = `${playerHeight}px`;
          placeholder.style.display = 'block';
          player.classList.add('fixed', 'bottom-0', 'left-0', 'right-0', 'z-50', 'shadow-lg', 'border-t', 'border-gray-200');
          player.style.maxWidth = '100%';
          // Add bottom padding to body to prevent content being covered
          document.body.style.paddingBottom = `${playerHeight}px`;
          isSticky = true;
        } else if (!shouldBeSticky && isSticky) {
          // Remove sticky
          player.classList.remove('fixed', 'bottom-0', 'left-0', 'right-0', 'z-50', 'shadow-lg', 'border-t', 'border-gray-200');
          document.body.style.paddingBottom = '';
          player.style.maxWidth = '';
          placeholder.style.display = 'none';
          isSticky = false;
        }
      }

      window.addEventListener('scroll', checkSticky, { passive: true });
      window.addEventListener('resize', checkSticky, { passive: true });
      checkSticky();
    });
  }

  // Check for auto-play flag from previous podcast
  function checkAutoPlayFromPreviousPodcast() {
    const autoplayFlag = localStorage.getItem('autoplay_next_podcast');
    if (autoplayFlag === 'true') {
      // Clear the flag
      localStorage.removeItem('autoplay_next_podcast');

      // Make sure dg tab is selected
      const dgTab = document.querySelector('.track-tab[data-track="dg"]') as HTMLElement;
      if (dgTab) {
        dgTab.click();
      }

      // Auto-play dg track after a short delay
      setTimeout(() => {
        const dgAudio = document.querySelector('#audio-dg') as HTMLAudioElement;
        if (dgAudio) {
          dgAudio.currentTime = 0;
          dgAudio.play();
        }
      }, 200);
    }
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    initTabs();
    initAudioPlayers();
    initStickyPlayer();
    checkAutoPlayFromPreviousPodcast();
  });

  // Also initialize on Astro page transitions
  document.addEventListener('astro:page-load', () => {
    initTabs();
    initAudioPlayers();
    initStickyPlayer();
    checkAutoPlayFromPreviousPodcast();
  });
</script>
